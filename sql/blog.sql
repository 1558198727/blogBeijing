/*
Navicat MySQL Data Transfer

Source Server         : liyunhao
Source Server Version : 50720
Source Host           : localhost:3306
Source Database       : yunblog

Target Server Type    : MYSQL
Target Server Version : 50720
File Encoding         : 65001

Date: 2018-04-05 16:29:05
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `blog`
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `blogId` int(11) NOT NULL AUTO_INCREMENT,
  `blogTitle` varchar(255) NOT NULL,
  `blogAnnotation` varchar(300) NOT NULL,
  `blogDate` date NOT NULL,
  `blogContent` longtext NOT NULL,
  PRIMARY KEY (`blogId`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('16', '第一篇博客', '第一篇博客', '2018-03-31', '\n\n> 这是第一篇博客    —— <a href=\"http://liyunhao.cn\" target=\"_blank\"> [李云皓]');
INSERT INTO `blog` VALUES ('17', '开学', '开学第一天', '2018-03-31', '**开学第一天一切如故！**');
INSERT INTO `blog` VALUES ('18', '在腾讯云上搭建个人静态博客', '一个不是很勉强的教程', '2018-03-31', '**2017年12月8日**\n\n这周开始学习在腾讯云上部署自己的博客。\n\n过程很有趣，特别是用域名访问自己部署的网页还是很有成就感的，所以决定写一遍文章来分享学习过程，\n希望路过的朋友可以多提一些建议，交流心得。\n\n一、我们需要知道的预备知识是：\n①前端开发的基础知识：html，css，JavaScript.\n这三个东西最为基础，但是却是前端开发的“三剑客”，很多的前端框架正是基于他们三个开发出来的。\n这里推荐前端学习的网站：W3C,菜鸟教程，对于前端初学者开说比较友好，它们提供了很多可以测试的实例，在网页编写的过程中可以随时看到运行效果。\n②服务器请求的相关知识：\n服务器端的编程语言有很多。\n可以使用java或者nodejs来搭建后台。\n\n以tomcat服务器为例，将自己写好的页面用tomcat发布到本地，可以通过hocalhost：8080端口访问。\n这一步很关键。关于tomcat服务器的安装及环境配置建议去慕课网学习。其中tomcat的运行需要java的环境。\n以下提供两个参考的学习案例：\n\njava环境配置\nhttp://www.imooc.com/video/1459\n有全部的安装教程及环境变量配置方法\n(jdk安装路径)JAVA_HOME :就是java文件夹下的jdk文件的位置 有时jdk文件夹后面可能有其它数字，因版本不同\n(jdk命令文件的位置)Path：jdk下的bin文件夹，（win10以下的版本要编辑已有的path，在最前面加上路径，之后用“；”隔开与其它路径）\n(jdk库文件的位置)CLASSPATH：jdk下的lib目录 注意在路径前加上.;\n\ntomcat配置\nhttp://blog.csdn.net/zhouzezhou/article/details/52450810\n在系统变量里新建变量名：CATALINA_BASE，变量值：D:\\tomcat\\apache-tomcat-9.0.0.M9\n在系统变量里新建变量名：CATALINA_HOME，变量值：D:\\tomcat\\apache-tomcat-9.0.0.M9\n在系统变量里打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin\n\n\n----------\nnodejs：\n在另一篇文章“nodejs搭建个人博客系统”里面有详细介绍，这里不再赘述。\n\n二、我们就可以将网页发布到腾讯云上了，一下步骤供参考：\n①购买域名\n![登录腾讯云首页注册账号](http://img.blog.csdn.net/20171208150222121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n②购买服务器\n![这里是服务器的基本配置，可以选择操作系统，带宽等](http://img.blog.csdn.net/20171208150845561?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![这里写图片描述](http://img.blog.csdn.net/20171208151017167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n对于个人博客系统其实不需要太高的配置，考虑到价格因素。\n另外腾讯云有学生主机，只要认证后就有很大的优惠。\n③域名解析\n\n这里需要说明的一点就是域名是需要备案的，提交之后方可使用，不然就是Internet的“黑户”了，\n过程略微有点烦，不过相信大家都是遵纪守法的好公民，可以很好完成这个任务，这里就不写过程了，按照上面的步骤来就行了。\n![这里你的服务器与云主机关联起来](http://img.blog.csdn.net/20171208151510898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n将域名绑定到自己主机公网IP上，\n绑定之后，大概十分钟，在你本地电脑的命令行执行\nping 你的域名  回车，\n如果正常收到你的主机ip发来的数据，说明你的域名解析成功了。\n\n三、配置云主机\n        这里以windows为例。\n        ①登录腾讯云官方网站，进入控制台，找到自己的主机，点击右侧的![这里写图片描述](http://img.blog.csdn.net/20180221093538945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)更多，之后选择windows操作系统，然后启动服务器。\n        ②在本地的电脑，win+R，输入mstsc回车，打开远程连接命令窗口，输入你的主机IP，以及密码进行连接，顺利的话之后就可以看到你的云服务器了，这个服务器由于是Windows的操作系统，所以看起来和自己本地的电脑没啥区别，这样就方便进行环境变量的配置了。\n        ③之后就可以将自己写好的静态博客发布到tomcat上面了。\n四、访问网页\n        在本地电脑打开浏览器，输入：“你的域名：端口号”，这个端口号tomcat默认是8080，你也可以修改他的端口号，具体方法自行百度，如果修改为80端口时，访问网页的时候就不需要加端口号，只要域名就可以访问网页。\n       以上是自己的学习过程的记录，欢迎点赞批评指正！');
INSERT INTO `blog` VALUES ('19', 'Part3000IsAlreadyInUse', 'node常见错误', '2018-03-31', '我们在使用webstorm的时候会经常遇到这样的情况，出现这种情况的原因：\n**①当我们同时在一个端口运行一个项目，再同时在这个端口运行其他项目时**\n**②同一个项目未停止直接关闭webstorm窗口，再次打开项目运行时**\n\n这时有一个万能的办法，那就是**重启电脑**，哈哈！**~~**\n\n开玩笑了，当然，这个端口上的进程是可以停掉的。\n打开cmd\n键入\n\n```\nnetstat -o -n -a | findstr :3000\n```\n\n3000为端口号，可以改为其他的。\n\n之后可以看到3000端口的进程：![这里写图片描述](http://img.blog.csdn.net/20180221151309633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n之后键入\n\n```\ntaskkill /F /PID 1776\n```\n则可以停掉对应序号的进程。之后再运行工程就不会有这种情况了。\n');
INSERT INTO `blog` VALUES ('20', 'chat', 'BLChat', '2018-03-31', '# BLChat\n## 简介  \nBLChat即时通讯APP\n\n## SDK版本\nAndroid 4.0.3\n\n## 测试环境\n小米2S、vivo x5pro\n\n## 开发环境\nAndroid Studio 2.3.3\n\n## 文件夹说明\nIMServer 文件夹存放的是服务器接口文件，需要在model文件夹下配置你的数据库账号密码\n\n## 功能模块划分\n1. 用户管理模块\n2. 好友管理模块\n3. 即时通讯模块\n4. 朋友圈模块\n\n## 界面\n### 开始界面\n![启动页面](http://i.imgur.com/jqQ2ZEw.png)\n### 主页面\n![主页面](http://i.imgur.com/8obW0Lv.png)\n![主页面2](http://i.imgur.com/GNOi64s.png)\n## 数据库设计\n### 用户信息列表\n字段名|说明|数据类型|约束\n:----:|:-----:|:-----:|:---:\n_id|索引	|整形|主码\nuser_id|用户ID|整型|非空\nuser_name|用户名|字符串，长度为30|非空\nuser_sex|性别|字符串，长度为４|非空\nuser_sign|用户个性签名|字符串，长度为180| \nuser_account|用户帐号|字符串，长度为30|非空\nuser_location|用户地区|字符串，长度为36|	\n\n### 好友信息表\n字段名|说明|数据类型|约束\n:----:|:-----:|:-----:|:---:\n_id	|索引	|整形	|主码\nfriend_id|好友ID	|整形|非空\ngroup_name|分组名称|字符串，长度为30|非空\nfriend_name|好友名称|字符串，长度为30|非空\nnick_name|昵称|字符串，长度为30|	 \nfriend_sex|好友性别|字符串，长度为4|非空\nfriend_account|好友帐号|字符串，长度为30|非空\nfriend_location|好友地区|字符串，长度为30|	 \nfriend_recent_photo|好友朋友圈展示图片	|字符串，长度为300|\n	\n### 聊天记录表\n字段名|说明|数据类型|约束\n:----:|:-----:|:-----:|:---:\n_id|索引|整形|主码\nuser_id|用户ID|整型|外键\nfriend_id|好友ID|整型|外键\nchat_msg_content|聊天内容|文本|非空\nchat_msg_time|聊天时间|日期|非空\nchat_msg_type|聊天类型，接受还是发送|字符串，长度为10|非空\nshow_time_flag|是否显示时间|整型|非空\n\n \n### 添加好友表\n字段名|说明|数据类型|约束\n:----:|:-----:|:-----:|:---:\n_id|索引|整形|主码\naccount|请求者账号|字符串，长度为30|非空\nreason|添加好友的请求信息|字符串，长度为30|默认为“您好”\nstatus|添加好友的状态|字符串，长度为10|非空\n\n### 服务器用户信息列表\n字段名|说明|数据类型|约束\n:----:|:-----:|:-----:|:---:\nid|索引|整形|主码\nusername|用户名|字符串，长度为30|非空\npassword|密码|字符串，长度为32|非空\nnickname|昵称|字符串，长度为18|非空\nsign|用户个性签名	|字符串，长度为180|无	 \nhead|用户头像|字符串，长度为180|无\nlocation	|用户地区|字符串，长度为36|无 	\naddtime|注册时间|DATETIME|非空 \nstatus|用户状态|Int|默认0	 \n\n');
INSERT INTO `blog` VALUES ('21', '大连理工大学软件学院数据结构第四章第九题', '数据结构上机', '2018-04-01', '测试');
INSERT INTO `blog` VALUES ('22', '大连理工大学软件学院数据结构第四章第九题', '数据结构上机', '2018-04-01', '测试');
INSERT INTO `blog` VALUES ('23', '大连理工大学软件学院数据结构第四章第九题', '数据结构', '2018-04-05', '\n/*\n 思想：利用拓扑排序来找图中的环，即离散数学中的w过程，\n 每次找到一条入度为零的边将其以及其所关联的边删除，\n  直到删除到环的时候再也进行不下去，此时将环中的任意\n  一个元素开始深度优先遍历即可。\n*/\n```\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntemplate<class EdgeType>\nclass Edge\n{\npublic:\n    int start,end;//边的起始节点，终止节点\n    EdgeType weight;//边的权重（应该可以定义为int）\n    Edge()\n    {\n       start=0;\n        end=0;\n        weight=0;\n    }\n    Edge(int st,int en,int w)\n    {\n        start=st;\n        end=en;\n        weight=w;\n    }\n    bool operator > (Edge oneEdge)\n    {\n        if(weight>oneEdge.weight)\n            return true;\n        else\n            return false;\n    }\n    bool operator < (Edge oneEdge)\n    {\n        if(weight<oneEdge.weight)\n            return true;\n        else\n            return false;\n    }\n};\n\ntemplate<class EdgeType>\nclass Graph\n{\n    public:\n    int vertexNum; //图中节点个数\n    int edgeNum;   //图中边的个数\n    int * Mark;    //标记某节点是否被访问\n    Graph(int verNum)\n    {\n        this->vertexNum=verNum;\n        edgeNum=0;\n        Mark=new int[vertexNum];\n        for(int i=0;i<vertexNum;i++)\n        {\n            Mark[i]=0; //都没有被访问过\n        }\n    }\n    ~Graph()\n    {\n        delete [] Mark;\n    }\n    //virtual Edge<EdgeType> FirstEdge(int oneVertex)=0;\n    //virtual Edge<EdgeType> NextEdge(Edge<EdgeType> oneEdge)=0;\n    int verticesNum()\n    {\n        return vertexNum;\n    }\n    int EdgesNum()\n    {\n        return edgeNum;\n    }\n    bool isEdge(Edge<EdgeType> oneEdge)\n    {\n        if(oneEdge.end>=0 && oneEdge.start>=0 && oneEdge.weight>0 && oneEdge.start!=oneEdge.end)//判断条件还不清楚\n        {\n            return true;\n        }\n        else\n        {\n          return false;\n        }\n    }\n    int startOfVertex(Edge<EdgeType> oneEdge)\n    {\n        return oneEdge.start;\n    }\n    int endOfVertex(Edge<EdgeType> oneEdge)\n    {\n        return oneEdge.end;\n    }\n    EdgeType weight(Edge<EdgeType> oneEdge) //返回oneEdge的权重\n    {\n        return oneEdge.weight;\n    }\n    //virtual void setEdge(int start,int end,int weight)=0;\n    //virtual void deleteEdge(int start,int end)=0;\n};\n\ntemplate<class EdgeType>\nclass AdjGraph : public Graph<EdgeType >\n{\n private:\n    int ** matrix;\n public:\n    AdjGraph(int verNum):Graph<EdgeType>(verNum)\n    {\n        matrix =new int * [verNum];\n        for(int i=0;i<verNum;i++)\n        {\n            matrix[i]=new int [verNum];\n        }\n        for(int i=0;i<verNum;i++)\n          for(int j=0;j<verNum;j++)\n        {\n            matrix[i][j]=999;\n        }\n    }\n\n    AdjGraph(int verNum,int **  a):Graph<EdgeType>(verNum)\n    {\n        matrix =new int * [verNum];\n        for(int i=0;i<verNum;i++)\n        {\n            matrix[i]=new int [verNum];\n        }\n        for(int i=0;i<verNum;i++)\n          for(int j=0;j<verNum;j++)\n          {\n\n            matrix[i][j]=a[i][j];\n          }\n    }\n\n    EdgeType getIJ(int i,int j)\n    {\n        if(i<this->vertexNum && i>=0 && j<this->vertexNum && j>=0)\n        return matrix[i][j];\n        else\n        {\n            cout<<\"邻接矩阵越界\"<<endl;\n            return 0;\n        }\n\n    }\n    int EdgesNum()\n    {\n        int edgeNum=0;\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            for(int j=0;j<this->vertexNum;j++)\n                if(matrix[i][j]<999)\n                    edgeNum++;\n        }\n        this->edgeNum=edgeNum;\n        return edgeNum;\n    }\n    void disp()\n    {\n        cout<<endl;\n        cout<<\"此图的领接矩阵为\"<<endl;\n        for(int i=0;i<this->vertexNum;i++)\n        {\n           for(int j=0;j<this->vertexNum;j++)\n           {\n             cout<<matrix[i][j]<<\" \";\n           }\n            cout<<endl;\n         }\n    }\n    ~AdjGraph()\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            matrix[i]=new int [this->vertexNum];\n        }\n        delete [] matrix;\n    }\n    Edge<EdgeType> FirstEdge(int oneVer) //返回顶点的第一条边\n    {\n        Edge<EdgeType> tem;\n        tem.start=oneVer;\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            if(matrix[oneVer][i]<999)\n            {\n                tem.end=i;\n                tem.weight=matrix[oneVer][i];\n                return tem;\n                //break;\n            }\n        }\n        tem.weight=-1;\n        tem.end=tem.start=0;\n        //cout<<\"没有符合条件的边\"<<endl;\n        return tem;\n    }\n\n    Edge<EdgeType> NextEdge(Edge<EdgeType> oneEdge)//返回与oneEdg有相同起点的下一条边\n    {\n        Edge<EdgeType> tem;\n        tem.start=oneEdge.start;\n        for(int i=oneEdge.end+1;i<this->vertexNum;i++)\n        {\n              if(matrix[oneEdge.start][i]<999)\n              {\n                 tem.end=i;\n                 tem.weight=matrix[oneEdge.start][i];\n                 return tem;\n              }\n        }\n        tem.weight=-1;\n        //cout<<\"没有符合条件的边\"<<endl;\n        return tem;\n    }\n    void visit(int i)\n    {\n        cout<<i<<\" \";\n    }\n\n    //深度优先搜索\n    void DFS(int i)//从i号节点开始深度优先搜索\n    {\n        this->Mark[i]=1;\n        //cout<<\"zhe次从这里开始深度遍历\"<<i<<endl;\n        visit(i);\n        for(Edge<EdgeType> e=FirstEdge(i);this->isEdge(e);e=NextEdge(e))\n        {\n             if(this->Mark[e.end]==0)\n             {\n                 //cout<<\"下次从这里开始深度遍历\"<<e.end<<endl;\n               DFS(e.end);\n             }\n        }\n\n    }\n    void DFSGraph()//对图进行深度优先搜索\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        this->Mark[i]=0;  //标记都未访问\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            if(this->Mark[i]==0)\n            {\n                DFS(i);\n            }\n        }\n\n    }\n    //广度优先搜索\n    void BFS(int i)//从i号节点开始广度优先搜索\n    {\n        queue<int> que;\n        que.push(i);\n        visit(i);\n        this->Mark[i]=1;\n        int p;\n        while(!que.empty())\n        {\n            p=que.front();\n            que.pop();\n            this->Mark[p]=1;\n            for(Edge<EdgeType> e=FirstEdge(p);this->isEdge(e);e=NextEdge(e))\n            {\n                if(this->Mark[e.end]==0)\n                {//此处要注意，在节点入队时候就要将Mark置为已访问，否则可能会导致同一节点多次入队\n                  visit(e.end);\n                  this->Mark[e.end]=1;\n                  que.push(e.end);\n                }\n            }\n        }\n    }\n\n    void BFSGraph()//对图进行广度优先搜索\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        this->Mark[i]=0;  //标记都未访问\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            if(this->Mark[i]==0)\n            {\n                BFS(i);\n            }\n        }\n       cout<<endl;\n    }\n\n};\n\n//拓扑排序，判断图中是否有环，并输出一个环\ntemplate<class EdgeType>\nvoid TopuSortJudeIsExitCricle(AdjGraph<EdgeType>& G,int * SortArray)//从S出发生成最短路径\n{\n        int n=G.verticesNum();\n        int * inderGree= new int [n];\n        for(int i=0;i<n;i++)\n        {\n            G.Mark[i]=0;\n            inderGree[i]=0;\n            SortArray[i]=-1;\n        }\n\n        for(int i=0;i<n;i++)\n        {\n          for(Edge<EdgeType> e = G.FirstEdge(i);G.isEdge(e);e=G.NextEdge(e))\n          {\n             //cout<<\"e的开头\"<<e.start<<endl;\n             //cout<<\"e的结尾\"<<e.end<<endl;\n             inderGree[e.end]++;\n          }\n         }\n         cout<<\"inder数组\"<<endl;\n         for(int j=0;j<n;j++)\n         {\n             cout<<inderGree[j]<<\" \";\n         }\n         cout<<endl;\n        for(int i=0;i<n;i++)\n        {\n            int v;\n            for(v=0;v<n;v++)\n            {\n                if(inderGree[v]==0 && G.Mark[v]==0)\n                {\n                    cout<<\"入度为零的点为\"<<v<<endl;\n                    break;\n                }\n            }\n            if(v==n)\n            {\n                cout<<\"图中存在环\"<<endl;\n                cout<<\"此时的mark数组\"<<endl;\n                for(int j=0;j<n;j++)\n                {\n                    cout<<G.Mark[j]<<\" \";\n                }\n                cout<<endl;\n                for(int j=0;j<n;j++)\n                {\n                    if(G.Mark[j]==0)\n                    {\n                        cout<<\"环从这里开始\"<<j<<endl;\n                        G.DFS(j);\n                        cout<<endl;\n                        return;\n                    }\n                }\n            }\n\n            G.Mark[v]=1;\n            SortArray[i]=v;\n\n            for(Edge<EdgeType> e = G.FirstEdge(v);G.isEdge(e);e=G.NextEdge(e))\n            {\n              inderGree[e.end]--;\n            }\n        }\n            delete [] inderGree;\n}\n\n\nint main()\n{\n    //课本p170的图\n    int tem[6][6]={\n        {999,  1,  1,  1,  1,  1},\n        {999,999,1  ,999,999,999},\n        {999,999,999,999,1  ,999},\n        {999,999,1  ,999,999,999},\n        {999,999,999,1  ,999,999},\n        {999,999,999,999,1  ,999},\n    };\n    int n=6;\n    int ** a=new int *[n];\n    for(int i=0;i<n;i++)\n    {\n        a[i]=new int [n];\n    }\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n    {\n        a[i][j]=tem[i][j];\n    }\n\n    AdjGraph<int> p(n,a);\n    p.disp();\n    cout<<\"深度优先搜索\"<<endl;\n    p.DFSGraph();\n    cout<<endl;\n    cout<<\"广度优先搜索\"<<endl;\n    p.BFSGraph();\n\n    int sortArray[n];\n    TopuSortJudeIsExitCricle(p,sortArray);\n    cout<<\"拓扑序列为\"<<endl;\n    for(int i=0;i<n;i++)\n    {\n        if(sortArray[i]>0)\n        cout<<sortArray[i]<<\" \";\n    }\n\n    cout<<endl;\n    return 0;\n}\n\n```');
INSERT INTO `blog` VALUES ('24', '图的邻接矩阵表示广度深度遍历', '数据结构', '2018-04-05', '\n```\n\n#include <iostream>\n#include <Queue.h>\n//队列，可用之前文章里面的Queue.h\nusing namespace std;\n\ntemplate<class EdgeType>\nclass Edge\n{\npublic:\n    int start,end;//边的起始节点，终止节点\n    EdgeType weight;//边的权重（应该可以定义为int）\n    Edge()\n    {\n       start=0;\n        end=0;\n        weight=0;\n    }\n    Edge(int st,int en,int w)\n    {\n        start=st;\n        end=en;\n        weight=w;\n    }\n    bool operator > (Edge oneEdge)\n    {\n        if(weight>oneEdge.weight)\n            return true;\n        else\n            return false;\n    }\n    bool operator < (Edge oneEdge)\n    {\n        if(weight<oneEdge.weight)\n            return true;\n        else\n            return false;\n    }\n};\n\ntemplate<class EdgeType>\nclass Graph\n{\n    public:\n    int vertexNum; //图中节点个数\n    int edgeNum;   //图中边的个数\n    int * Mark;    //标记某节点是否被访问\n    Graph(int verNum)\n    {\n        this->vertexNum=verNum;\n        edgeNum=0;\n        Mark=new int[vertexNum];\n        for(int i=0;i<vertexNum;i++)\n        {\n            Mark[i]=0; //都没有被访问过\n        }\n    }\n    ~Graph()\n    {\n        delete [] Mark;\n    }\n    //virtual Edge<EdgeType> FirstEdge(int oneVertex)=0;\n    //virtual Edge<EdgeType> NextEdge(Edge<EdgeType> oneEdge)=0;\n    int verticesNum()\n    {\n        return vertexNum;\n    }\n    int EdgesNum()\n    {\n        return edgeNum;\n    }\n    bool isEdge(Edge<EdgeType> oneEdge)\n    {\n        if(oneEdge.end>=0 && oneEdge.start>=0 && oneEdge.weight>0)//判断条件还不清楚\n        {\n            return true;\n        }\n        else\n        {\n          return false;\n        }\n    }\n    int startOfVertex(Edge<EdgeType> oneEdge)\n    {\n        return oneEdge.start;\n    }\n    int endOfVertex(Edge<EdgeType> oneEdge)\n    {\n        return oneEdge.end;\n    }\n    EdgeType weight(Edge<EdgeType> oneEdge) //返回oneEdge的权重\n    {\n        return oneEdge.weight;\n    }\n    //virtual void setEdge(int start,int end,int weight)=0;\n    //virtual void deleteEdge(int start,int end)=0;\n};\n\ntemplate<class EdgeType>\nclass AdjGraph : public Graph<EdgeType >\n{\n private:\n    int ** matrix;\n public:\n    AdjGraph(int verNum):Graph<EdgeType>(verNum)\n    {\n        matrix =new int * [verNum];\n        for(int i=0;i<verNum;i++)\n        {\n            matrix[i]=new int [verNum];\n        }\n        for(int i=0;i<verNum;i++)\n          for(int j=0;j<verNum;j++)\n        {\n            matrix[i][j]=0;\n        }\n    }\n\n    AdjGraph(int verNum,int **  a):Graph<EdgeType>(verNum)\n    {\n        matrix =new int * [verNum];\n        for(int i=0;i<verNum;i++)\n        {\n            matrix[i]=new int [verNum];\n        }\n        for(int i=0;i<verNum;i++)\n          for(int j=0;j<verNum;j++)\n          {\n\n            matrix[i][j]=a[i][j];\n          }\n    }\n    void disp()\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        {\n           for(int j=0;j<this->vertexNum;j++)\n           {\n             cout<<matrix[i][j]<<\" \";\n           }\n            cout<<endl;\n         }\n    }\n    ~AdjGraph()\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            matrix[i]=new int [this->vertexNum];\n        }\n        delete [] matrix;\n    }\n    Edge<EdgeType> FirstEdge(int oneVer) //返回顶点的第一条边\n    {\n        Edge<EdgeType> tem;\n        tem.start=oneVer;\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            if(matrix[oneVer][i]!=0)\n            {\n                tem.end=i;\n                tem.weight=matrix[oneVer][i];\n                return tem;\n                //break;\n            }\n        }\n        //cout<<\"没有符合条件的边\"<<endl;\n        //return;\n    }\n    Edge<EdgeType> NextEdge(Edge<EdgeType> oneEdge)//返回与oneEdg有相同起点的下一条边\n    {\n        Edge<EdgeType> tem;\n        tem.start=oneEdge.start;\n        for(int i=oneEdge.end+1;i<this->vertexNum;i++)\n        {\n              if(matrix[oneEdge.start][i]!=0)\n              {\n                 tem.end=i;\n                 tem.weight=matrix[oneEdge.start][i];\n                 return tem;\n              }\n        }\n        //cout<<\"没有符合条件的边\"<<endl;\n        //return;\n    }\n    void visit(int i)\n    {\n        cout<<\"正在访问\"<<i+1<<\"号节点\"<<endl;\n    }\n\n    //深度优先搜索\n    void DFS(int i)//从i号节点开始深度优先搜索\n    {\n        this->Mark[i]=1;\n        visit(i);\n        for(Edge<EdgeType> e=FirstEdge(i);this->isEdge(e);e=NextEdge(e))\n        {\n             if(this->Mark[e.end]==0)\n             {\n               DFS(e.end);\n             }\n        }\n\n    }\n    void DFSGraph()//对图进行深度优先搜索\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        this->Mark[i]=0;  //标记都未访问\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            if(this->Mark[i]==0)\n            {\n                DFS(i);\n            }\n        }\n\n    }\n    //广度优先搜索\n    void BFS(int i)//从i号节点开始广度优先搜索\n    {\n        Queue<int> que;\n        que.EnQueue(i);\n        visit(i);\n        this->Mark[i]=1;\n        int p;\n        while(!que.IsEmpty())\n        {\n            que.DeQueue(p);\n            this->Mark[p]=1;\n            for(Edge<EdgeType> e=FirstEdge(p);this->isEdge(e);e=NextEdge(e))\n            {\n                if(this->Mark[e.end]==0)\n                {//此处要注意，在节点入队时候就要将Mark置为已访问，否则可能会导致同一节点多次入队\n                  visit(e.end);\n                  this->Mark[e.end]=1;\n                  que.EnQueue(e.end);\n                }\n            }\n        }\n    }\n\n    void BFSGraph()//对图进行广度优先搜索\n    {\n        for(int i=0;i<this->vertexNum;i++)\n        this->Mark[i]=0;  //标记都未访问\n        for(int i=0;i<this->vertexNum;i++)\n        {\n            if(this->Mark[i]==0)\n            {\n                BFS(i);\n            }\n        }\n\n    }\n};\n\nint main()\n{\n    //课本p160页的图\n    int tem[8][8]={\n        {0,1,1,0,0,0,0,0},\n        {1,0,0,1,1,0,0,0},\n        {1,0,0,0,0,1,1,0},\n        {0,1,0,0,0,0,0,1},\n        {0,1,0,0,0,0,0,1},\n        {0,0,1,0,0,0,1,0},\n        {0,0,1,0,0,1,0,0},\n        {0,0,0,1,1,0,0,0},\n    };\n    int ** a=new int *[8];\n    for(int i=0;i<8;i++)\n    {\n        a[i]=new int [8];\n    }\n    for(int i=0;i<8;i++)\n      for(int j=0;j<8;j++)\n    {\n        a[i][j]=tem[i][j];\n    }\n\n    AdjGraph<int> p(8,a);\n    p.disp();\n   // p.DFSGraph();\n    p.BFSGraph();\n\n    return 0;\n}\n\n```\n![main函数里构造的图](http://img.blog.csdn.net/20171210214341700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTDE1NTgxOTg3Mjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)');
INSERT INTO `blog` VALUES ('25', 'node', 'node简介', '2018-04-05', '# Node.js-Notes\n个人的 Node.js 学习笔记，有兴趣的小伙伴可以了解下，希望能帮到你们。\n### 目录\n1. [Introduction](#introduction)\n	- [简介](#简介)\n	- [特点](#特点)\n	- [适合开发领域](#适合开发领域)\n	- [总结](#总结)\n2. [安装Node.js](#install-nodejs)\n3. [NPM node.js 模块管理](#npm-nodejs-模块管理)	\n	- [NPM简介](#npm简介)\n	- [NPM常用命令](#npm常用命令)\n4. [开始第一个 node.js web 实例](#开始第一个-nodejs-web-实例)\n5. [node.js 回调函数](#nodejs-回调函数)\n	- [1. 同步操作文件(阻塞I/O)](#1-同步操作文件阻塞io) 	\n	- [2. 异步操作文件(非阻塞I/O)](#2-异步操作文件非阻塞io)\n6. [Node.js 事件循环](#nodejs-事件循环)\n	- [自定义模块](#自定义模块)\n7. [Node.js 函数](#nodejs-函数)\n	- [常用函数](#常用函数)\n	- [匿名函数](#匿名函数)\n8. [Node.js 路由](#nodejs-路由)\n9. [Node.js 全局对象](#nodejs-全局对象)\n	- [__filename](#__filename)\n	- [__dirname](#__dirname)\n	- [console](#console)\n	- [process](#process)\n10. [Node.js 常用工具](#nodejs-常用工具)\n	- [util.inspect 将任意对象转换 为字符串](#utilinspect-将任意对象转换-为字符串)\n	- [util.isArray() 判断是否是数组](#utilisarray-判断是否是数组)\n	- [util.isBoolean() 判断是否是boolean类型的](#utilisboolean-判断是否是boolean类型的)\n	- [util.isDate() 判断是否是日期](#utilisdate-判断是否是日期)\n	- [util.isFunction() 判断是否是函数](#utilisfunction-判断是否是函数)\n	- [util.isObject() 判断是否是对象](#utilisobject-判断是否是对象)\n	- [util.isRegExp() 是否是正则对象](#utilisregexp-是否是正则对象)\n11. [文件系统](#文件系统)\n	- [读文件内容](#读文件内容)\n		- [1. 异步非堵塞读取](#1-异步非堵塞读取)\n		- [2. 同步堵塞读取](#2-同步堵塞读取)\n	- [写文件内容](#写文件内容)\n	- [删除文件](#删除文件)\n	- [创建目录](#创建目录)\n	- [删除目录](#删除目录)\n12. [GET和POST请求](#get和post请求)\n	- [GET请求](#get请求)\n	- [POST请求](#post请求)\n13. [工具模块](#工具模块)\n	- [OS模块](#os模块)\n	- [Path模块](#path模块)\n	- [Net模块](#net模块)\n	- [DNS模块](#dns模块)\n	- [Domain模块](#domain模块)\n14. [MySql](#mysql)\n	- [查询数据](#查询数据)\n	- [插入数据](#插入数据)\n	- [更新数据](#更新数据)\n	- [删除数据](#删除数据)\n15. [HTTP模块](#http模块)\n16. [静态文件夹](#静态文件夹)\n\n# Introduction\n## 简介 \n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br> \nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br> \nNode.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n## 特点\n### 单线程\n![单线程](http://i.imgur.com/aX2lBae.png)\n> 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。<br>\nNode.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。<br>\n另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。\n坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。\n\n### 非阻塞I/O non-blocking I/O \n> 例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。<br>\n由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。<br>\n当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。<br>\n阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。\n\n### 事件驱动 event-driven\n> 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。<br>\nNode.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度，这是鬼才才能想到的。针尖上的舞蹈，用一个线程，担负起了处理非常多的任务的使命。\n\n## 适合开发领域\n> Node.js 善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。<br>\n> 当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。<br>\n> 比如:<br>\n> - 用户表单收集\n> - 考试系统\n> - 聊天室\n> - 图文直播\n> - 提供JSON的API（为前台Angular使用）\n\n## 总结\n![原理图](http://i.imgur.com/DPHgbYn.png)\n> 单线程，单线程的好处，减少了内存开销，操作系统的内存换页。如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。<br>\n> 非阻塞I/O， 不会傻等I/O语句结束，而会执行后面的语句。<br>\n> 事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。\n\n\n# Install Node.js\n1. 下载node.js\n	\n	前往[https://nodejs.org/en/](https://nodejs.org/en/ \"https://nodejs.org/en/\")下载node.js稳定版\n	![下载稳定版](http://i.imgur.com/1byvubu.png)\n\n\n2. 安装环境(windows 7 64位环境下)\n	\n	- 一直Next就可以了\n	\n	![安装](http://i.imgur.com/gRew5uL.png)\n	\n	- 在终端直接查看node.js的版本，查询到即安装成功\n	\n	![安装完成](http://i.imgur.com/awvnLdR.png)\n\n\n3. 结合Sublime开发\n	\n	- 创建新的编译环境\n	\n	  ![创建新编译环境](http://i.imgur.com/IDga1Cv.png)\n	- 在里面写入\n	``` Bash\n	{\n		\"cmd\": [\"node\", \"$file\"],\n		\"selector\": \"source.js\"\n	}\n	```\n	- 保存并重命名\n	\n	![保存并重命名](http://i.imgur.com/Jzs3iNo.png)\n	- 写一个js文件，输出Hello World.按Ctrl+B进行编译，如果无反应，请重启sublime，出现Hello World即为成功\n	\n	![sublime](http://i.imgur.com/LXs03iI.png)\n\n# NPM node.js 模块管理 \n## NPM简介\n>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：\n>- 允许用户从NPM服务器下载别人编写的第三方包到本地使用。\n>- 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\n>- 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\n \n## NPM常用命令\n1. `npm list`\n	查看本地模块\n2. `npm install mysql`\n	安装mysql模块\n3. `npm uninstall mysql`\n	卸载mysql模块\n4. `npm root`\n	本地模块根目录\n5. `npm root -g`\n	本服务器所有模块根目录\n6. `npm update mysql`\n	升级mysql模块\n7. `npm search mysql`\n	搜索mysql模块\n8. `npm -help <command>`\n	查看帮助\n\n# 开始第一个 node.js web 实例\n```JavaScript\n//加载http web模块\nconst http = require(\'http\');\ncs = function (req, res) {\n	//设置head头\n	res.writeHead(\'200\',{\'content-type\':\'text/html;charset=utf-8\'});\n	//给客户端返回内容\n	res.write(\'hello world! Gavin first Node.js Web\'); \n	res.end();\n}\n//监听端口\nhttp.createServer(cs).listen(666);\nconsole.log(\'http is ok\');\n```\n![第一个web应用](http://i.imgur.com/uqEFm2H.png)\n# node.js 回调函数\n>Node.js 异步编程的直接体现就是回调。\n异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。\n回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。\n例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。\n\n## 1. 同步操作文件(阻塞I/O)\n```JavaScript\n //加载fs file 模块\n const fs = require(\'fs\');\n file = \"test.txt\";\n //开始读取文件\n console.log(\'file start\');\n //正在读取文件\n data = fs.readFileSync(file);\n console.log(data.toString());\n //读取文件结束\n console.log(\'file end！\');\n```\n![同步操作文件](http://i.imgur.com/PuaItru.png)\n## 2. 异步操作文件(非阻塞I/O)\n```JavaScript\n//加载fs file 模块\nconst fs = require(\'fs\');\nfile = \"test.txt\";\n//开始读取文件\nconsole.log(\'file start\');\n//正在读取文件\n//自带事件(当文件内容读取完毕时)\nfs.readFile(file,function(err, data){\n	 console.log(data.toString());\n});\n//读取文件结束\nconsole.log(\'file end！\');\n```\n![异步操作文件](http://i.imgur.com/kX5fFsu.png)\n# Node.js 事件循环\n>Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。<br>\n>Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。<br>\n>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。<br>\n>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.<br>\n\n```JavaScript\nconst events = require(\'events\');\nevt = new events.EventEmitter();\nfunction eventHandler(){\n	console.log(\'run\');\n}\n//当触发eventName时，调用eventHandler\nevt.on(\'eventName\',eventHandler);\n//触发eventName\nevt.emit(\'eventName\');\n```\n\n# Node.js 模块\n> 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。<br>\n模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n\n## 自定义模块\n在demo.js同级目录下创建show.js，编写模块代码\n``` Javascript\n// 自定义show模块\n// 定义show类\nfunction show() {\n	this.name = \'user\';\n	this.say = function(){\n		console.log(\'my name is \' + this.name);\n	}\n}\nmodule.exports = new show();\n```\n在demo.js文件中调用我们自定义的show模块\n``` JavaScript\n//调用自定义模块\nconst show = require(\'./show\');\nshow.say();\n```\n\n# Node.js 函数\n## 常用函数\n``` Javascript\nfunction show(){\n	console.log(\'show\');\n}\n```\n## 匿名函数\n``` Javascript\nshow = function(){\n	console.log(\'show\');\n}\n```\n\n# Node.js 路由\n自己写个路由，一般实际应用大多是直接用框架\n``` JavaScript\nconst http = require(\'http\');\nconst url = require(\'url\');\ncs = function(request,res){\n	urlStr = request.url; //获取访问url路径字符串\n	urlPath = url.parse(urlStr).pathname; //转换url路径\n	res.writeHead(\'200\',{\'content-type\':\'text/html;charset=utf-8\'});\n	switch (urlPath) { //选择页面\n		case \'/index\':\n			res.write(\'index page\');\n			break;\n		case \'/add\':\n			res.write(\'add page\');\n			break;\n		case \'/delete\':\n			res.write(\'delete page\');\n			break;\n		case \'/update\':\n			res.write(\'update page\');\n			break;\n		case \'/sreach\':\n			res.write(\'sreach\');\n			break;\n		default:\n			res.write(\'undefined page\');\n	}	\n	console.log(\"访问的url路径:\"+urlPath);\n	res.end();\n}\nhttp.createServer(cs).listen(666);\nconsole.log(\'Server Is Running Successfully!\');\n```\n![路由](http://i.imgur.com/NAGU7hj.png)\n# Node.js 全局对象\n## __filename\n本文件全路径<br>\n`console.log(__filename);`<br>\n输出：D:\\NodeWorkSpace\\demo.js\n## __dirname\n表示当前执行脚本所在的目录。<br>\n`console.log(__dirname);`<br>\n输出：D:\\NodeWorkSpace\n## console\n1. `console.log` 向标准输出流打印字符并以换行符结束\n2. `console.info` 该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。\n3. `console.warn` 输出警告消息。控制台出现有黄色的惊叹号。\n4. `console.error` 输出错误消息的。控制台在出现错误时会显示是红色的叉子。\n5. `console.time`输出时间，表示计时开始。\n6. `console.timeEnd`结束时间，表示计时结束\n\n``` javascript\nconsole.log(\"log\");\nconsole.info(\"information\");\nconsole.warn(\"warn\");\nconsole.error(\"error\");\nconsole.time(\'x\');\nfor (var i = 0; i <= 100000; i++) {\n	\n}\nconsole.timeEnd(\'x\');\n```\n![console](http://i.imgur.com/pMfXeKB.png)\n## process\n### 属性\n1. `stdout` 标准输出流。\n2. `stderr` 标准错误流。\n3. `stdin` 标准输入流。\n4. `argv` argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。\n5. `execPath` 返回执行当前脚本的 Node 二进制文件的绝对路径。\n6. `execArgv` 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。\n7. `env` 返回一个对象，成员为当前 shell 的环境变量\n8. `exitCode` 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。\n9. `version` Node 的版本，比如v0.10.18。\n10. `versions` 一个属性，包含了 node 的版本和依赖.\n11. `config` 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 \"config.gypi\" 文件相同。\n12. `pid` 当前进程的进程号。\n13. `title` 进程名，默认值为\"node\"，可以自定义该值。\n14. `arch` 当前 CPU 的架构：\'arm\'、\'ia32\' 或者 \'x64\'。\n15. `platform` 运行程序所在的平台系统 \'darwin\', \'freebsd\', \'linux\', \'sunos\' 或 \'win32\'\n16. `mainModule` require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。\n\n### 方法\n1. `abort()` 这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。\n2. `chdir(directory)` 改变当前工作进程的目录，如果操作失败抛出异常。\n3. `cwd()` 返回当前进程的工作目录\n4. `exit([code])` 使用指定的 code 结束进程。如果忽略，将会使用 code 0。\n5. `getgid()` 获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。\n6. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n7. `setgid(id)` 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。\n8. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n9. `getuid()` 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。\n10. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n11. `setuid(id)` 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。\n12. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n13. `getgroups()` 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。\n14. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n15. `setgroups(groups)` 设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。\n16. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n17. `initgroups(user, extra_group)` 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。\n18. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。\n19. `kill(pid[, signal])` 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 \'SIGINT\' 或 \'SIGHUP\'。如果忽略，信号会是 \'SIGTERM\'。\n20. `memoryUsage()` 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。\n21. `nextTick(callback)` 一旦当前事件循环结束，调用回到函数。\n22. `umask([mask])` 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。\n23. `uptime()` 返回 Node 已经运行的秒数。\n24. `hrtime()` 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。\n\n### 示例\n``` JavaScript\nversion = process.version;\nconsole.log(version);\ncwd = process.cwd();\nconsole.log(cwd);\n```\n输出：\nv6.11.0\nD:\\NodeWorkSpace\n\n# Node.js 常用工具\n1. ### `util.inspect()` 将任意对象转换 为字符串\n``` JavaScript\n// 加载模块\nconst util = require(\'util\');\nobj = {\'name\':\'Gavin\',\'sex\':\'male\',\'age\':\'16\'}\nconsole.log(typeof(obj));\nconsole.log(util.inspect(obj));\nconsole.log(typeof(util.inspect(obj)));\n```\n> 输出：\nobject\n{ name: \'Gavin\', sex: \'male\', age: \'16\' }\nstring\n2. ### `util.isArray()` 判断是否是数组\n```JavaScript\n// 加载模块\nconst util = require(\'util\');\narr = [\'a\',\'b\',\'c\'];\nconsole.log(util.isArray(arr));\n```\n>输出：true\n3. ### `util.isBoolean()` 判断是否是boolean类型的\n``` JavaScript\n// 加载模块\nconst util = require(\'util\');\nobj = {\'name\':\'Gavin\',\'sex\':\'male\',\'age\':\'16\'}\nconsole.log(util.isBoolean(obj));\n```\n>输出：false\n4. ### `util.isDate()` 判断是否是日期\n``` JavaScript\n// 加载模块\nconst util = require(\'util\');\ntobj = new Date();\nconsole.log(util.isDate(tobj))\n```\n>输出：true\n5. ### `util.isFunction()` 判断是否是函数\n6. ### `util.isObject()` 判断是否是对象\n7. ### `util.isRegExp()` 是否是正则对象\n``` JavaScript\n// 加载模块\nconst util = require(\'util\');\nconsole.log(util.isRegExp(/^\\d{11}$/ig));\n```\n>输出：true\n\n# 文件系统\n> 这里写个测试的文件`test.txt`内容如下\n11111\n22222\n33333\n44444\n55555\n66666\n\n## 读文件内容\n### 1. 异步非堵塞读取\n> readFile();\n\n```JavaScript\n //加载文件模块\nconst fs = require(\'fs\');\nfile = \'test.txt\';\n//异步读取\nfs.readFile(file,function(err,data){\n	str = data.toString();\n	console.log(str);\n});\nconsole.log(\'file read end！\');\n```\n![异步](http://i.imgur.com/DmcVEga.png)\n### 2. 同步堵塞读取\n> readFileSync();\n\n```JavaScript\n//加载文件模块\nconst fs = require(\'fs\');\nfile = \'test.txt\';\n//同步读取\ndata = fs.readFileSync(file);\nstr = data.toString();\nconsole.log(str);\n```\n![同步读取](http://i.imgur.com/koKPCZT.png)\n\n## 写文件内容\n> writeFile();\n\n``` JavaScript\nconst fs = require(\'fs\');\nfile = \'test1.txt\';\nstr  = \"1111\\n2222\\n3333\";\n// 文件异步写入\nfs.writeFile(file,str);\nconsole.log(\'file write end！\');\n```\n> 因为之前没有file1.txt所以就创建了一个新的文件夹\n\n![](http://i.imgur.com/cEqt4Iu.png)<br>\n![写入文件内容](http://i.imgur.com/lcoO6Ym.png)\n## 删除文件\n> unlink();\n\n``` JavaScript\n//加载文件模块\nconst fs = require(\'fs\');\nfile = \'test1.txt\';\nfs.unlink(file);\n```\n## 创建目录\n> mkdir();\n\n``` JavaScript\n//加载文件模块\nconst fs = require(\'fs\');\nfile = \'testdir\';\nfs.mkdir(file);\n```\n\n## 删除目录\n> rmdir();\n\n``` JavaScript\n//加载文件模块\nconst fs = require(\'fs\');\nfile = \'testdir\';\nfs.rmdir(file);\n```\n\n# GET和POST请求\n## GET请求\n``` JavaScript\n//加载web模块\nconst http = require(\'http\');\n//加载url模块\nconst url = require(\'url\');\n//加载querystring模块\nconst querystring = require(\'querystring\');\n\ncs = function(req, res){\n	uri = req.url;\n	if (uri !== \'/favicon.ico\') {\n		console.log(uri);\n		// 获取get参数字符串\n		str = url.parse(uri).query;\n		console.log(str);\n		// 将参数字符串转换为json对象\n		json = querystring.parse(str);\n		console.log(json);\n		res.write(\'Gavin\\\' Web server !\');\n		res.end();\n	}\n}\nhttp.createServer(cs).listen(666);\nconsole.log(\'Http Is Running Successfully!\');\n```\n> 在浏览器输入url地址 http://localhost:666/index?id=1&name=Gavin\n\n![](http://i.imgur.com/Pi0Ciw2.png)\n![](http://i.imgur.com/47kM23w.png)\n\n## POST请求\n> POST请求代码\n\n``` JavaScript\n// 加载web模块\nconst http = require(\'http\');\n// 加载querystring模块\nconst querystring = require(\'querystring\');\n// 加载工具模块\nconst util = require(\'util\');\n// 服务器回调函数\ncs = function(req, res){\n	// 定义了一个post变量，用于暂存请求体的信息\n    var post = \'\';     \n    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中\n    req.on(\'data\', function(chunk){ \n    	console.log(\"chunk:\"+chunk);   \n        post += chunk;\n    });\n    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。\n    req.on(\'end\', function(){    \n        post = querystring.parse(post);\n        res.end(util.inspect(post));\n    });\n}\nhttp.createServer(cs).listen(666);\nconsole.log(\'Http Is Running Successfully!\');\n```\n> POST请求测试页面\n\n``` HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n	<meta charset=\"UTF-8\">\n	<title>Post请求测试页面</title>\n</head>\n<body>\n	<form action=\"http://localhost:666/\" method=\"post\">\n		<p>姓名：<input type=\"text\" name=\"Name\"></p>\n		<p>年龄：<input type=\"text\" name=\"Age\"></p>\n		<input type=\"submit\">\n	</form>\n</body>\n</html>\n```\n![](http://i.imgur.com/cajISzH.png)<br>\n![](http://i.imgur.com/yiDU9tI.png)\n![](http://i.imgur.com/T8vinq3.png)\n\n# 工具模块\n> 一些基本的系统操作函数\n\n## OS模块\n### 方法\n#### `os.tmpdir()` 返回操作系统的默认临时文件夹。\n#### `os.endianness()` 返回 CPU 的字节序，可能的是 \"BE\" 或 \"LE\"。\n#### `os.hostname()` 返回操作系统的主机名。\n#### `os.type()` 返回操作系统名\n#### `os.platform()` 返回操作系统名\n#### `os.arch()` 返回操作系统 CPU 架构，可能的值有 \"x64\"、\"arm\" 和 \"ia32\"。\n#### `os.release()` 返回操作系统的发行版本。\n#### `os.uptime()` 返回操作系统运行的时间，以秒为单位。\n#### `os.loadavg()` 返回一个包含 1、5、15 分钟平均负载的数组。\n#### `os.totalmem()` 返回系统内存总量，单位为字节。\n#### `os.freemem()` 返回操作系统空闲内存量，单位是字节。\n#### `os.cpus()` 返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。\n#### `os.networkInterfaces()` 获得网络接口列表。\n### 属性\n#### `os.EOL` 定义了操作系统的行尾符的常量。\n\n### 实例\n``` JavaScript\nconst os = require(\'os\');\n// 返回操作系统的默认临时文件夹。\nconsole.log(os.tmpdir()); \n// 返回操作系统名\nconsole.log(os.platform());\n```\n> 输出：\n> C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\nwin32\n\n## Path模块\n### 方法\n#### `path.normalize(p)` 规范化路径，注意\'..\' 和 \'.\'。\n#### `path.join([path1][, path2][, ...])` 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是\"/\"，Windows系统是\"\\\"。\n#### `path.resolve([from ...], to)` 将 to 参数解析为绝对路径。\n#### `path.isAbsolute(path)` 判断参数 path 是否是绝对路径。\n#### `path.relative(from, to)` 用于将相对路径转为绝对路径。\n#### `path.dirname(p)` 返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。\n#### `path.basename(p[, ext])` 返回路径中的最后一部分。同 Unix 命令 bashname 类似。\n#### `path.extname(p)` 返回路径中文件的后缀名，即路径中最后一个\'.\'之后的部分。如果一个路径中并不包含\'.\'或该路径只包含一个\'.\' 且这个\'.\'为路径的第一个字符，则此命令返回空字符串。\n#### `path.parse(pathString)` 返回路径字符串的对象。\n#### `path.format(pathObject)` 从对象中返回路径字符串，和 path.parse 相反。\n\n### 属性\n#### `path.sep` 平台的文件路径分隔符，\'\\\\\' 或 \'/\'。\n#### `path.delimiter` 平台的分隔符, ; or \':\'.\n#### `path.posix` 提供上述 path 的方法，不过总是以 posix 兼容的方式交互。\n#### `path.win32` 提供上述 path 的方法，不过总是以 win32 兼容的方式交互\n\n### 实例\n\n``` JavaScript\nconst path = require(\'path\');\n// 判断是否是绝对路径\nconsole.log(path.isAbsolute(\"C:/\\Users/\\ADMINI~1/\\AppData/\\Local/\\Temp/\\test.txt\"));\n//返回路径中文件的后缀名\nconsole.log(path.extname(\"C:/\\Users/\\ADMINI~1/\\AppData/\\Local/\\Temp/\\test.txt\"));\n//平台的分隔符\nconsole.log(path.delimiter);\n```\n> 输出\n> true\n.txt\n;\n\n\n## Net模块\n### 方法\n#### `net.createServer([options][, connectionListener])` 创建一个 TCP 服务器。参数 connectionListener 自动给 \'connection\' 事件创建监听器。\n#### `net.connect(options[, connectionListener])` 返回一个新的 \'net.Socket\'，并连接到指定的地址和端口。\n当 socket 建立的时候，将会触发 \'connect\' 事件。\n#### `net.createConnection(options[, connectionListener])` 创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 \'localhost\'。\n#### `net.connect(port[, host][, connectListener])` 创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 \'localhost\'。参数 connectListener 将会作为监听器添加到 \'connect\' 事件。返回 \'net.Socket\'。\n#### `net.createConnection(port[, host][, connectListener])` 创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 \'localhost\'。参数 connectListener 将会作为监听器添加到 \'connect\' 事件。返回 \'net.Socket\'。\n#### `net.connect(path[, connectListener])` 创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 \'connect\' 事件上。返回 \'net.Socket\'。\n#### `net.createConnection(path[, connectListener])` 创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 \'connect\' 事件。返回 \'net.Socket\'。\n#### `net.isIP(input)` 检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。\n#### `net.isIPv4(input)` 如果输入的地址为 IPV4， 返回 true，否则返回 false。\n#### `net.isIPv6(input)` 如果输入的地址为 IPV6， 返回 true，否则返回 false。\n\n### net.Server\n> net.Server通常用于创建一个 TCP 或本地服务器\n\n#### `server.listen(port[, host][, backlog][, callback])` 监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。\n#### `server.listen(path[, callback])` 通过指定 path 的连接，启动一个本地 socket 服务器。\n#### `server.listen(handle[, callback])` 通过指定句柄连接。\n#### `server.listen(options[, callback])` options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。\n#### `server.close([callback])` 服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 \'close\' 事件。\n#### `server.address()` 操作系统返回绑定的地址，协议族名和服务器端口。\n#### `server.unref()` 如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。\n#### `server.ref()` 与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。\n#### `server.getConnections(callback)` 异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。\n\n### 事件\n#### `listening` 当服务器调用 server.listen 绑定后会触发。\n#### `connection` 当新连接创建后会被触发。socket 是 net.Socket实例。\n#### `close` 服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。\n#### `error` 发生错误时触发。\'close\' 事件将被下列事件直接调用。\n\n### net.Socket\n>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。\n\n### net.Socket事件\n#### `lookup` 在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。\n#### `connect` 成功建立 socket 连接时触发。\n#### `data` 当接收到数据时触发。\n#### `end` 当 socket 另一端发送 FIN 包时，触发该事件。\n#### `timeout` 当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。\n#### `drain` 当写缓存为空得时候触发。可用来控制上传。\n#### `error` 错误发生时触发。\n#### `close` 当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。\n\n### net.Socket属性\n#### `socket.bufferSize` 该属性显示了要写入缓冲区的字节数。\n#### `socket.remoteAddress` 远程的 IP 地址字符串，例如：\'74.125.127.100\' or \'2001:4860:a005::68\'。\n#### `socket.remoteFamily` 远程IP协议族字符串，比如 \'IPv4\' or \'IPv6\'。\n#### `socket.remotePort` 远程端口，数字表示，例如：80 or 21。\n#### `socket.localAddress` 网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听\'0.0.0.0\'而客户端连接在\'192.168.1.1\'，这个值就会是 \'192.168.1.1\'。\n#### `socket.localPort` 本地端口地址，数字表示。例如：80 or 21。\n#### `socket.bytesRead` 接收到得字节数。\n#### `socket.bytesWritten` 发送的字节数。\n\n### net.Socket方法\n#### `new net.Socket([options])` 构造一个新的 socket 对象。\n#### `socket.connect(port[, host][, connectListener])` 指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。\n#### `socket.connect(path[, connectListener])` 打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。\n#### `socket.setEncoding([encoding])` 设置编码\n#### `socket.write(data[, encoding][, callback])` 在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。\n#### `socket.end([data][, encoding])` 半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。\n#### `socket.destroy()` 确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。\n#### `socket.pause()` 暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。\n#### `socket.resume()` 调用 pause() 后想恢复读取数据。\n#### `socket.setTimeout(timeout[, callback])` socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。\n#### `socket.setNoDelay([noDelay])` 禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。\n#### `socket.setKeepAlive([enable][, initialDelay])` 禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.\n#### `socket.address()` 操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: \'IPv4\', address: \'127.0.0.1\' }。\n#### `socket.unref()` 如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。\n#### `socket.ref()` 与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。\n\n### 实例\n> Telnet 服务器实例\n\n``` JavaScript\nconst net = require(\'net\');\nchat = net.createServer();\n//但客户端连接时\nchat.on(\'connection\', function(client){\n	// 给客户端发送Hello World\n	client.write(\'hello world\');\n	// 当接收到发来信息时\n	client.on(\'data\',function(data){\n		console.log(data.toString());\n	});\n});\nchat.listen(9000);\nconsole.log(\'server ok\');\n```\n> 在Windows Dos界面(cmd)，输入: telnet 127.0.0.1 9000\n\n![Telnet服务器实例](http://i.imgur.com/MD3nyZv.png)\n\n## DNS模块\n### 方法\n#### `dns.lookup(hostname[, options], callback)` 将域名（比如 \'runoob.com\'）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。\n#### `dns.lookupService(address, port, callback)` 使用 getnameinfo 解析传入的地址和端口为域名和服务。\n#### `dns.resolve(hostname[, rrtype], callback)` 将一个域名（如 \'runoob.com\'）解析为一个 rrtype 指定记录类型的数组。\n#### `dns.resolve4(hostname, callback)` 和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[\'74.125.79.104\', \'74.125.79.105\', \'74.125.79.106\']）。\n#### `dns.resolve6(hostname, callback)` 和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）\n#### `dns.resolveMx(hostname, callback)` 和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。\n#### `dns.resolveTxt(hostname, callback)` 和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [\'v=spf1 ip4:0.0.0.0 \', \'~all\' ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。\n#### `dns.resolveSrv(hostname, callback)` 和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{\'priority\': 10, \'weight\': 5, \'port\': 21223, \'name\': \'service.example.com\'}, ...]）。\n#### `dns.resolveSoa(hostname, callback)` 和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。\n#### `dns.resolveNs(hostname, callback)` 和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [\'ns1.example.com\', \'ns2.example.com\']）。\n#### `dns.resolveCname(hostname, callback)` 和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [\'bar.example.com\']）。\n#### `dns.reverse(ip, callback)` 反向解析 IP 地址，指向该 IP 地址的域名数组。\n#### `dns.getServers()` 返回一个用于当前解析的 IP 地址数组的字符串。\n#### `dns.setServers(servers)` 指定一组 IP 地址作为解析服务器。\n\n### 实例\n``` JavaScript\nconst dns = require(\'dns\');\ndomain = \"www.baidu.com\";\n// 通过域名找IP\ndns.lookup(domain,function(err,ip,family){\n	console.log(\'IP is ：\' + ip);\n});\n```\n> 输出： IP is ：14.215.177.38\n\n## Domain模块\n### 方法\n#### `domain.run(function)` 在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。\n#### `domain.add(emitter)` 显式的增加事件\n#### `domain.remove(emitter)` 删除事件。\n#### `domain.bind(callback)` 返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。\n#### `domain.intercept(callback)` 和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。\n#### `domain.enter()` 进入一个异步调用的上下文，绑定到domain。\n#### `domain.exit()` 退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。\n#### `domain.dispose()` 释放一个domain对象，让node进程回收这部分资源。\n#### `domain.create()` 返回一个domain对象。\n\n### 属性\n#### `domain.members` 已加入domain对象的域定时器和事件发射器的数组。\n\n\n# MySql\n> 首先安装mysql模块\n> 通过命令：npm install mysql\n> 创建数据库node_mysql\n> 创建user表,表字典如下\n\n|字段名|属性|备注|\n|:--:|:--:|:--:|\n|id|int|主键|\n|name|varchar|非空|\n|age|int|非空|\n\n> 数据库插入数据后的表\n\n![](http://i.imgur.com/zfZFrxW.png)\n\n## 查询数据\n``` JavaScript\n//查询数据\nconst mysql = require(\'mysql\');\nconn = mysql.createConnection({\n	host:\'localhost\',\n	user:\'root\',\n	password:\'abcdef123\',\n	port:\'3306\',\n	database:\'node_mysql\',\n});\n//建立连接\nconn.connect();\n//准备sql语句\nsql = \"select * from user\";\n//查询数据库\nconn.query(sql,function(err,result){\n	if (err) {\n		console.log(\'error:\',err.message);\n	}else {\n		for(i = 0; i < result.length; i++){\n			console.log(\"id  :\" + result[i][\'id\']);\n			console.log(\"name:\" + result[i][\'name\']);\n			console.log(\"age :\" + result[i][\'age\']);\n			console.log(\"-----------------\");\n		}\n	}\n});\n//关闭数据库连接\nconn.end();\n```\n> 输出结果：<br>\n> id  :1<br>\nname:Gavin<br>\nage :16<br>\n\\-----------------<br>\nid  :2<br>\nname:Gavin<br>\nage :18<br>\n\\-----------------\n\n## 插入数据\n``` JavaScript\n//插入数据\nconst mysql = require(\'mysql\');\nconn = mysql.createConnection({\n	host:\'localhost\', \n	user:\'root\',\n	password:\'abcdef123\',\n	port:\'3306\',\n	database:\'node_mysql\',\n});\n//建立连接\nconn.connect();\n//准备sql语句\nsql = \"insert into user(name,age) values(?,?)\";\ndata = [\'Gavin\',\'22\'];\n//查询数据库\nconn.query(sql,data,function(err,result){\n	if (err) {\n		console.log(\'error:\',err.message);\n	}else {\n		console.log(\'AffectedRows :\',result[\'affectedRows\']);\n	}\n});\n//关闭数据库连接\nconn.end();\n```\n> 输出：AffectedRows : 1 \n\n![](http://i.imgur.com/Bs7FpEK.png)\n\n## 更新数据\n``` JavaScript\n//更新数据\nconst mysql = require(\'mysql\');\nconn = mysql.createConnection({\n	host:\'localhost\', \n	user:\'root\',\n	password:\'abcdef123\',\n	port:\'3306\',\n	database:\'node_mysql\',\n});\n//建立连接\nconn.connect();\n//准备sql语句\nsql = \"update user set age=? where id=?\";\ndata = [\'15\',\'1\'];\n//查询数据库\nconn.query(sql,data,function(err,result){\n	if (err) {\n		console.log(\'error:\',err.message);\n	}else {\n		console.log(\'AffectedRows :\',result[\'affectedRows\']);\n	}\n});\n//关闭数据库连接\nconn.end();\n```\n> 输出：AffectedRows : 1\n\n![](http://i.imgur.com/CnZsCyo.png)\n\n## 删除数据\n``` JavaScript\n//删除数据\nconst mysql = require(\'mysql\');\nconn = mysql.createConnection({\n	host:\'localhost\', \n	user:\'root\',\n	password:\'abcdef123\',\n	port:\'3306\',\n	database:\'node_mysql\',\n});\n//建立连接\nconn.connect();\n//准备sql语句\nsql = \"delete from user where id=1\";\n//查询数据库\nconn.query(sql,function(err,result){\n	if (err) {\n		console.log(\'error:\',err.message);\n	}else {\n		console.log(\'AffectedRows :\',result[\'affectedRows\']);\n	}\n});\n//关闭数据库连接\nconn.end();\n```\n> 输出：AffectedRows : 1\n\n![删除数据](http://i.imgur.com/44bkwD6.png)\n\n# HTTP模块\n``` JavaScript\n//引用模块\nvar http = require(\"http\");\n\n//创建一个服务器，回调函数表示接收到请求之后做的事情\nvar server = http.createServer(function(req,res){\n	//req参数表示请求，res表示响应\n	console.log(\"服务器接收到了请求\" + req.url);\n	//设置头部\n	res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF8\"});\n	res.write(\"<h1>我是主标题</h1>\");\n	res.write(\"<h2>我是2标题</h2>\");\n	res.write(\"<h3>我是3标题</h3>\");\n	res.end((1+2+3).toString());\n});\n\n//监听端口\nserver.listen(3000,\"127.0.0.1\");\n```\n## Request\n### url 模块\n``` JavaScript\nvar http = require(\"http\");\n\nvar server = http.createServer(function(req,res){\n	console.log(req.url);\n	res.end();\n});\n\nserver.listen(3000,\"127.0.0.1\");\n```\n``` JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nvar server = http.createServer(function(req,res){\n	//url.parse()可以将一个完整的URL地址，分为很多部分：\n	//host、port、pathname、path、query\n	var pathname = url.parse(req.url).pathname;\n	//url.parse()如果第二个参数是true，那么就可以将所有的查询变为对象\n	//就可以直接打点得到这个参数\n	var query = url.parse(req.url,true).query;\n	//直接打点得到这个参数\n	var age = query.age;\n	\n	console.log(\"pathname:\" + pathname);\n	console.log(query);\n	console.log(\"age:\" + age);\n	\n	res.end();\n});\n\nserver.listen(3000,\"127.0.0.1\");\n```\n> 输入网址：http://localhost:3000/?age=18<br>\n> 输出：<br>\n> pathname:/<br>\n> { age: \'18\' } <br>\n> age:18 <br>\n\n# 静态文件夹\n> 访问静态文件夹<br>\n> 文件目录<br>\n>  - static\n>    - index.html\n>    - 404.html\n>  - app.js\n\n--------------------- \n\n> app.js\n\n```JavaScript\nvar http = require(\"http\");\nvar url = require(\"url\");\nvar fs = require(\"fs\"); \nvar path = require(\"path\");\n\nvar server = http.createServer(function(req,res){\n    // 获取用户的路径\n    var pathname = url.parse(req.url).pathname;\n    // 获取拓展名\n	var extname = path.extname(pathname);\n    // 读取这个文件\n    fs.readFile(\"./static/\" + pathname, function(err, data){\n        if(err){\n            // 如果此文件不存在， 就返回404返回\n            fs.readFile(\"./static/404.html\", function(err, data){\n                res.writeHead(404, {\"Content-type\": \"text/html;charset = UTF8\"});\n                res.end(data);\n            });\n            return;\n        };\n        var mime = getMime(extname);\n		res.writeHead(200,{\"Content-type\":mime});\n        res.end(data);\n    })\n});\nfunction getMime(extname){\n    switch(extname){\n        case \".html\":\n            return \"text/html\";\n            break;\n        case \".jpg\":\n            return \"image/jpg\";\n            break;\n        case \".css\":\n            return \"text/css\";\n            break;\n        case \".js\":\n            return \"text/javascript\";\n            break;\n    }\n}\nserver.listen(3000,\"127.0.0.1\");\n```\n> static/index.html\n\n``` HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>这是一个静态的HTML页面</h1>\n</body>\n</html>\n```\n> static/404.html\n\n``` HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>这是一个404页面</h1>\n</body>\n</html>\n```');
